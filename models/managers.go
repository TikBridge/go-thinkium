package models

import (
	"errors"
	"fmt"
	"math/big"
	"net"
	"reflect"

	c1 "github.com/ThinkiumGroup/go-cipher"
	"github.com/ThinkiumGroup/go-common"
	"github.com/ThinkiumGroup/go-common/db"
	"github.com/ThinkiumGroup/go-common/trie"
	"github.com/ThinkiumGroup/go-thinkium/config"
	"github.com/sirupsen/logrus"
)

var (
	ErrMainChainOnly = errors.New("supported by main chain only")
)

type (
	BlockAppendSuccess  func(block *BlockEMessage, hashOfHeader []byte) error
	BlockValidateFailed func(block *BlockEMessage, hashOfHeader []byte, fail error) error

	// snapshot of chain status
	ChainSnapshot struct {
		Height     common.Height    // current height
		Block      *BlockEMessage   // block of current height
		Waterlines []ShardWaterline // waterlines of shards at current height
		CheckEpoch bool             // whether to check epoch matchness
	}

	// since v2.11.5, the infos for the first block after the sub-chain restarted
	RestartingInfo struct {
		Restarted *RestartedComm // !=nil means IsFirstOfRestarting==true
		Rebooted  *RebootedComm  // since v2.12.0
	}

	ProposeResult struct {
		Processed          []*Transaction    // executed transactions
		ProcessedPas       []*PubAndSig      // the signatures corresponding to the executed transactions one by one
		TxParams           [][]byte          // since v2.14.2, parameters generated by proposer for the processed transactions
		StateRoot          []byte            // world state tree root hash after transaction execution
		DeltaTrie          *AccountDeltaTrie // DeltaTrie generated after transaction execution
		ReceiptsHash       []byte            // hash value of all executed transactions receipts
		RRActReceiptsRoot  []byte            // root hash value of all applied RRActs receipts
		VccRoot            []byte            // root hash of signed check tree
		CashedRoot         []byte            // root hash of cashed check tree
		RREra              common.EraNum     // current era of reward chain
		RRRoot             []byte            // root hash of required reserve tree at current era in reward chain
		RRNextRoot         []byte            // root hash of required reserve tree at next era in reward chain
		RRChangingRoot     []byte            // root hash of modification request tree currently to be applied in reward chain
		ChainInfoRoot      []byte            // root hash of chain info tree in main chain
		WaterlinesRoot     []byte            // merkle root hash of all waterline values of all shards after the completion of delta merge and transaction execution
		RewardedCursor     *common.Height    //
		RewardedEra        *common.EraNum    // since v2.12.0
		Hds                []*BlockSummary   // summaries
		ConfirmedRoot      []byte            // root of ConfirmedTrie
		Preelectings       PreElectings      // since v2.11.5, preelection and restartings, moved from ChainEngine.ProposeNewBlock
		PreelectingResults ChainElectResults // since v2.11.5, results of preelection and restartings, moved from ChainEngine.ProposeNewBlock
		RestartingInfo                       // since v2.11.5
		RewardRequests     RewardRequests    // since v2.12.0
		RandomSig          []byte            // since v3.2.0
		AttendanceRecord   *AttendanceRecord // since v3.2.1
		SeedFactor         SeedFactor        // since v3.2.1
	}

	WholeWorld struct {
		State          *trie.Trie
		Chains         *trie.Trie
		History        *trie.HistoryTree
		Waterlines     []ShardWaterline
		Vcc            *trie.Trie
		Cashed         *trie.Trie
		RREra          *common.EraNum
		RRCurrent      *trie.Trie
		RRNext         *trie.Trie
		RRChanging     *trie.Trie
		PreElectings   PreElectings
		Deltas         DeltaFroms
		Confirmed      *trie.Trie
		BridgeInfos    *trie.Trie
		BridgeSessions *BridgeSessionTrie
	}

	DataHolder interface {
		Simulating() bool
		Estimate(tx *Transaction, header *BlockHeader) (uint64, error)
		GetShardInfo() common.ShardInfo
		SetGenesisHeader(header *BlockHeader) error
		GetChainInfo() (*common.ChainInfos, bool)
		GetGenesisNodes() map[common.NodeID]common.NodeType
		GetDataNodeList() common.NodeIDs
		IsDataNode() bool    // is it the data node of current chain
		IsMemoNode() bool    // is it the full node of current chain
		IsRewardChain() bool // is the current chain the reward chain
		IncCount(height common.Height, timestamp uint64, count uint64)
		// FIXME: should not reture database to other layer
		GetDb() db.Database
		SetDB(newDB db.Database)

		CurrentBlock() *BlockEMessage
		GetBlockTxIndexs(txHash []byte) (*TXIndex, error)
		GetBlockByHash(hoh []byte) (*BlockEMessage, error)
		GetBlock(height common.Height) (*BlockEMessage, error)
		GetBlockWithUnverified(height common.Height) (*BlockEMessage, error)
		SaveUnverifiedBlock(block *BlockEMessage) error
		GetBlockHash(height common.Height) (*common.Hash, bool)
		GetHeader(height common.Height) (*BlockHeader, error)
		// GetPreviousHeaderOf(height common.Height) (*BlockHeader, error)
		GetEthHeader(height uint64) common.Hash
		GetHistoryRoot(expectingHeight common.Height) ([]byte, error)
		// SaveRewardRequests(block *BlockEMessage, hashOfBlock []byte) error

		CreateEmptyAccountTrie() *trie.Trie
		CreateAccountTrie(rootHash []byte) *trie.Trie
		RestoreHistoryTreeFromProofs(lastHeight common.Height, lastHeightHash []byte,
			proofs trie.ProofChain) (*trie.HistoryTree, error)
		CreateHistoryTree(root []byte, checkPrecedingNil bool) (*trie.HistoryTree, error)
		CreateEmptyVccOrigin() *trie.Trie
		CreateEmptyCashedOrigin() *trie.Trie
		SyncState(height common.Height, block *BlockEMessage, states *WholeWorld, logger logrus.FieldLogger) error
		SyncChains(chains *trie.Trie) error
		GetConfirmedInfo(id common.ChainID) *ConfirmedInfo
		GetConfirmedInfoAtRoot(id common.ChainID, root []byte) *ConfirmedInfo
		UpdateNewElectedCommByRestartHistories(parentHeight common.Height, epoch common.EpochNum) error
		FindARestartToRollbackTo(chainid common.ChainID) (common.Height, []byte, error)
		ResetConfirmedInfos(confirmeds ChainConfirmeds) (root []byte, err error)
		ResetBridgeInfos(infos []*BridgeInfo) (root []byte, err error)
		ResetBridgePeers(peers []*BridgePeerSession) (root []byte, err error)
		SyncAccTrie(height common.Height, accStates *trie.Trie) error
		SyncBlock(block *BlockEMessage) error
		IsSyncing() bool
		// IsSynced returns 0 if the chain is not yet synced, and returns 1 if synced
		IsSyncedAt(height common.Height) bool
		IsSynced() bool
		SetSynced()
		TimedOut() bool
		IsFull() bool
		StopSyncing()
		SetNotLeader()
		IsLeader() bool
		IsEmpty() bool
		IsExpectingEpoch(epoch common.EpochNum) error
		GetCurrentHeight() common.Height
		// SetCurrentHeight(height common.Height)
		ResetToHeight(height common.Height, hob common.Hash) error

		GetWorldStateRoot() ([]byte, error)
		SnapshotRoots() (snapshot *ChainSnapshot, err error)
		GetWorldStateStream(snapshot *ChainSnapshot) (streams *StateStreams, err error)
		GetCashCheckState(vccRoot, cashedRoot []byte) (vccs, casheds [][]byte, err error)

		// GetReceipts returns receipt list in specific block by its receiptsHash
		GetReceiptsByRoot(receiptHash common.Hash) Receipts
		CallProcessTx(tx *Transaction, senderSig *PubAndSig, blockHeader *BlockHeader) (interface{}, error)

		ProposeData(ctx *ConsensusContext, froms DeltaFroms, header *BlockHeader, txs []*Transaction,
			pas []*PubAndSig) (result *ProposeResult, err error)
		PrepareBlock(ctx *ConsensusContext, block *BlockEMessage) error
		PutBlock(ctx *ConsensusContext, block *BlockEMessage, appendSuccessFunc BlockAppendSuccess,
			validateFailedFunc BlockValidateFailed) error

		ForceCommit() (err error)

		// CreateRootDeltaTrie() *AccountDeltaTrie
		// RestoreDeltaTrieFromBlock recover complete AccountDeltaTrie from blockã€‚
		RestoreDeltaTrieFromBlock(block *BlockEMessage) (*AccountDeltaTrie, error)

		SaveReceivedDelta(fromID common.ChainID, height common.Height, deltas []*AccountDelta) (
			overflow bool, waterline common.Height, overflowed []*DeltaFrom, missing bool, missingLength int, err error)
		SaveDeltasGroup(fromID common.ChainID, group DeltasGroup) (overflow bool,
			waterline common.Height, overflowed []*DeltaFrom, missing bool, missingLength int, err error)

		CheckReceivedDelta(fromID common.ChainID, height common.Height) bool

		CreateAccountDeltaTrie() trie.ITrie
		PopDeltaFroms() DeltaFroms
		PutDeltaFroms(deltaFroms DeltaFroms)
		CreateDeltaFromTrie() *AccountDeltaFromTrie
		ShouldSendDelta() (A, B common.Height, confirmingProof ConfirmingProof, err error)
		SetDeltaToBeSent(height common.Height)
		VerifyDeltasPack(pack *DeltasPack) error

		// Verifiable Cash Check Trie
		AddVCC(vcc *CashCheck) (hashOfVcc []byte, err error)
		DeleteVCC(vcc *CashCheck) (ok bool, hashOfVcc []byte, err error)
		VccProof(vcc *CashCheck) (height, mainHeight common.Height, proofChain trie.ProofChain, proofedHash []byte, err error)
		AddCCC(vcc *CashCheck, txHash *common.Hash) (hashOfVcc []byte, err error)
		CCCExsitenceProof(ccc *CashCheck) (height, mainHeight common.Height, existence bool, existProof trie.ProofChain,
			cashedRootProof trie.ProofChain, proofedHash []byte, err error)
		GetCCCRelativeTx(hashOfVcc []byte) (hashOfTx []byte, err error)

		CreateVCCTrie(root []byte) *trie.Trie
		CreateCCCTrie(root []byte) *trie.Trie

		// required reserve
		RRDeposit(fromChain common.ChainID, fromTxHash common.Hash, height common.Height, typ common.NodeType,
			nodeIdHash common.Hash, addr common.Address, amount *big.Int, withNodeSig bool) (mergedTo *common.Hash, merged bool, err error)
		RRWithdraw(fromChain common.ChainID, fromTxHash common.Hash, height common.Height,
			nodeIdHash common.Hash, addr common.Address) (mergedTo *common.Hash, merged bool, err error)
		RRWithdrawPart(fromChain common.ChainID, fromTxHash common.Hash, height common.Height,
			nodeIdHash common.Hash, addr common.Address, amount *big.Int) (mergedTo *common.Hash, merged bool, err error)
		RRChangeStatus(fromChain common.ChainID, fromTxHash common.Hash, height common.Height,
			nodeIdHash common.Hash, newStatus uint16, setOrClr bool) (mergedTo *common.Hash, merged bool, err error)
		RRPenalize(fromChain common.ChainID, fromTxHash common.Hash,
			height common.Height, nodeIdHash common.Hash, penalRate *big.Rat, penalValue *big.Int) (
			estimated *big.Int, err error)
		RRDelegate(fromChain common.ChainID, fromTxHash common.Hash, height common.Height,
			nodeIdHash common.Hash, amount *big.Int) (mergedTo *common.Hash, merged bool, err error)
		RRUnDelegate(fromChain common.ChainID, fromTxHash common.Hash, height common.Height,
			nodeIdHash common.Hash, amount *big.Int) (mergedTo *common.Hash, merged bool, err error)
		RRGetCurrentDepositByAddress(addr common.Address) (map[common.Hash]*RRInfo, bool)
		RRStatus() (era common.EraNum, current, next, changing []byte, err error)
		GetRRProof(expectingRootHash common.Hash, nodeIdHash common.Hash) (*RRProofs, error)
		GetInfosForSync(rrRoot, rrNextRoot, rrChangingRoot []byte) (rrdata *RRSyncData, err error)
		ProduceRRTries(rrdata *RRSyncData) (rr, rrn, rrc *trie.Trie, err error)

		GetAccount(addr *common.Address) (*Account, bool)
		GetAccountAtHeight(height common.Height, addr *common.Address) (*Account, error)
		GetCodeByHash(codeHash common.Hash) []byte
		GetGasSettings() (gasPrice *big.Int, gasLimit uint64)

		SwitchEpoch()
		HasChild() bool

		// Record the committee election result comm of chainid chain in epoch num. if comm is
		// not available, prev is the last effective committee.
		// Because the parent chain needs to keep the consensus committee information of the
		// sub chain, chainId is necessary.
		PutCommittee(chainId common.ChainID, epochNum common.EpochNum, startHeight common.Height,
			electedHeight common.Height, comm *Committee, prev *Committee) error
		ResetEpochAllComm(chainid common.ChainID, epoch common.EpochNum, eac *EpochAllCommittee) error
		GetCommittee(chainId common.ChainID, height common.Height) (*Committee, error)
		GetEpochComm(chainId common.ChainID, epochNum common.EpochNum) (*EpochAllCommittee, error)
		SyncCommittees(currentHeight common.Height) ([]*ChainEpochCommittee, error)
		PutCommitteeIndex(block *BlockEMessage) error
		GetCommitteeWithBlockProof(commEpoch common.EpochNum) (block *BlockEMessage, hob []byte,
			comm *Committee, commProof trie.ProofChain, lastHeight common.Height, lastProof trie.ProofChain, err error)

		GetLastConfirmingProofOf(subId common.ChainID) (ConfirmingProof, error)
		ProofFinalBlock(A, B common.Height) (hashOfA []byte, blockOfB *BlockEMessage,
			proofs trie.ProofChain, err error)

		// Interfaces used to record whether messages have been processed
		Process(hash common.Hash) bool
		Processed(hash common.Hash) bool
		RemoveProcessed(hash common.Hash)
		ClearProcessed()

		AppendHistory(height common.Height, hash []byte) (newRoot []byte, err error)
		SetWaitingForSyncFinish(targetNodeId *common.NodeID) bool
		IsWaitingForSyncFinish() (*common.NodeID, bool)
		ClrWaitingForSyncFinish()
		SetSyncFinish(height common.Height)
		SetSyncFinishIfLess(height common.Height)
		GetSyncFinish() common.Height

		SetCursorManually(to common.Height) error

		GetStateDB() StateDB

		GetRRInfo(nodeIdHash common.Hash) *RRInfo
		GetCurrentRRChanging(nodeIdHash common.Hash) *RRC
		CreateRRTrie(rootHash []byte) *trie.Trie
		CreateRRChangingTrie(root []byte) *trie.Trie

		// ProcessBlockRewardRequests(startingNonce uint64, processingMainBlock *BlockEMessage,
		// 	currentMainHeight common.Height) (rtxs []*Transaction, rpas []*PubAndSig, processed bool)

		GetConsistantLong(addr common.Address, key common.Hash) []byte
		SetLongState(addr common.Address, key common.Hash, value []byte)

		// interfaces for chain management
		MCHCreateChain(header *BlockHeader, info *common.ChainInfos) error
		MCHRemoveChain(id common.ChainID) error
		MCHStartChain(id common.ChainID, header *BlockHeader) (err error)
		MCHAddBootNode(id common.ChainID, bootNode common.Dataserver) (errr error)
		MCHRemoveBootNode(id common.ChainID, nodeId common.NodeID) error
		MCHAddDataNode(id common.ChainID, nodeId common.NodeID, rrRoot *common.Hash, rrProof *RRProofs) error
		MCHRemoveDataNode(id common.ChainID, nodeId common.NodeID) error
		MCHAddAdmin(id common.ChainID, adminPub []byte) error
		MCHDelAdmin(id common.ChainID, adminPub []byte) error
		MCHAttributes(id common.ChainID, isSet bool, attrs ...common.ChainAttr) error
		MCHRestartChain(chainId common.ChainID, epochNum common.EpochNum, commIds common.NodeIDs) error
		// interfaces for election
		GetPreElecting(id common.ChainID) *PreElecting
		PutPreElectResult(resulter ElectResulter)
		// call in main chain
		IsRestartingElected(id common.ChainID) (is bool, electedAt *BlockEMessage, lastHeight common.Height, lastHash *common.Hash)
		// call in sub chain
		IsFirstOfRestarting() (is bool, electedAt common.Height, electedHob *common.Hash, restarted *RestartedComm, err error)
		MainChainRebootable(msg *RebootMainChainMessage) (*RebootMainChainMessage, error)
		SaveRebootComm(startHeight common.Height, comm *Committee, name ElectingName)
		RebootingMainChainStatus(msg *RebootMainChainMessage) error
		ModifyEmptyBlock(block *BlockEMessage) error
		// ProposePreElecting(height common.Height) (PreElectings, ChainElectResults)
		SetPreelectExamineResult(chainId common.ChainID, success bool) error
		SyncPreElection(electings PreElectings)
		MergeProof(key uint64, value []byte, proofs trie.ProofChain) error

		// interface for check nodes
		CacheAliveDataNode(id common.NodeID, height common.Height)
		LoadAliveDataNodes() common.NodeIDs
		ClearAliveDataNodes(height common.Height)

		// interface for update version
		UpdateVersionInfo(versionInfo *config.VersionData) error
		LoadVersionInfo() (*config.VersionData, error)

		// buffers
		// BufEvent(event BufferEvent, pub, sig []byte) error
		// PutAuditing(auditing *AuditingMessage, auditors map[common.NodeID]struct{}) (int, int, error)
		// GetAuditings(height common.Height, header *BlockHeader) (AuditorPass, error)
		// VerifyReport(report *BlockReport) error
		// TryReportBlock(height common.Height) (*BlockReport, common.Height, error)

		StoreConfirmBlock(block *BlockEMessage) error
		LoadConfirmBlock() (*BlockEMessage, error)

		ProofHashOfBlockA2B(a, b common.Height) (hashOfB []byte, proof trie.ProofChain, err error)
		// TrySendRewardReq() ([]*RewardRequest, error)

		Rollback()
		// since 3.1 sync world state from tmp db
		CopyChainInfos(tmpDB db.Database, snapshot *ChainSnapshot) (err error)
		CopyAccounts(tmpDB db.Database, snapshot *ChainSnapshot) (err error)
		RebuildAccounts(tmpDB db.Database, stateRoot []byte) (*trie.Trie, error)
		CopyConfirmed(tmpDB db.Database, snapshot *ChainSnapshot) (err error)
		RebuildConfirmed(tmpDB db.Database, root *common.Hash) (err error)
		CopyDeltaFroms(tmpDB db.Database, snapshot *ChainSnapshot) (err error)
		CopyVccCashesTrie(tmpDB db.Database, snapshot *ChainSnapshot) (err error)
		RebuildVccCashesTrie(tmpDB db.Database, vccRoot []byte, cashedRoot []byte) (vccTrie *trie.Trie, cashedTrie *trie.Trie)

		CopyBridgeSessions(tmpDB db.Database, snapshot *ChainSnapshot) error
		RebuildBridgeSessions(tmpDB db.Database, root []byte) error
		CopyBridgeInfos(tmpDB db.Database, snapshot *ChainSnapshot) error
		RebuildBridgeInfos(tmpDB db.Database, root []byte) error

		CreateBridgeInfoTrie(root []byte) *trie.Trie
		AddBridgeInfo(info *BridgeInfo) error
		RemoveBridgeInfo(chain common.ChainID, contract common.Address) error
		ListBridgeInfosOf(chain common.ChainID, contract common.Address) []*BridgeInfo
		GetBridgeInfoTo(toChain common.ChainID, toContract common.Address) *BridgeInfo
		UpdateBridgeReqCursor(sourceChain common.ChainID, cursor common.Height) bool
		UpdateBridgeRespCursor(targetChain common.ChainID, cursor common.Height) bool
		SaveBridgeRequest(req *BridgeReq) error
		FindFailedRequest(targetChain common.ChainID, account common.Address, nonce uint64) *BridgeReq
		DeleteRequest(targetChain common.ChainID, reqHeight common.Height, account common.Address, nonce uint64) (deleted *BridgeReq)
		UpdateBridgeReqStatus(toChain common.ChainID, reqHeight common.Height,
			account common.Address, nonce uint64, status BridgeReqStatus) error
		ListBridgeSessionsToAt(blockHeight common.Height, toChainId common.ChainID, reqHeight common.Height) (
			reqCursor, respCursor common.Height, reqs []*BridgeReq, resps []*BridgeResp, err error)
		RemoveBridgeReqs(toChain common.ChainID, cursor common.Height) error
		SaveBridgeResponse(resp *BridgeResp) error
		RemoveBridgeResps(toChain common.ChainID, cursor common.Height) error

		DumpTries(newDB db.Database, block *BlockEMessage, states *WholeWorld) (err error)
	}

	DataManager interface {
		common.Service
		Simulating() bool
		Simulate() (DataManager, error)
		Eventer() Eventer
		SetChainStructs(chains *config.Config)
		InitOneChain(chainid common.ChainID) error
		CreateGenesisData(chainId common.ChainID) error
		CreateChainInfosOrigin(rootHash []byte) *trie.Trie
		GetChainInfos(id common.ChainID) (*common.ChainInfos, bool)
		IsInUsingDataNode(dataNodeId common.NodeID) (common.ChainID, bool)
		IsNoGasChain(chainId common.ChainID) (bool, common.ChainID)
		GetConfirmedsAt(id common.ChainID, height common.Height) (common.Height, []byte, ChainConfirmeds, error)
		GetChainStats(id common.ChainID) (*ChainStats, error)
		DataNodeOf() common.ChainID
		DataOrMemoOf() common.ChainID
		IsDataNode() bool
		IsMemoNode() bool
		IsDataOrMemo() bool
		// Deprecated
		IsDataMemoNode() bool
		GetShardInfo(chainid common.ChainID) common.ShardInfo
		IsDataNodeOf(id common.ChainID) bool
		IsDataOrMemoOf(id common.ChainID) bool
		IsAuditorOf(id common.ChainID) (c1.ECCPrivateKey, bool)
		IsShard(id common.ChainID) bool
		HasAttribute(id common.ChainID, attr common.ChainAttr) bool
		IsLeaf(id common.ChainID) bool
		GetChainChildren(chainid common.ChainID) common.ChainIDs
		GetChainChildrenAndSelfInfos(chainid common.ChainID) []*common.ChainInfos
		// GetDataNodes(id common.ChainID) map[common.NodeID]struct{}
		GetGenesisDataNodeList(id common.ChainID) common.NodeIDs
		GetDataNodeList(id common.ChainID) common.NodeIDs
		GetDataNodeIDs(chainId common.ChainID) common.NodeIDs // Return if there is a list of Genesis data nodes, otherwise return to the list of data nodes
		GetChainList() common.ChainIDs
		NoMainChainList() common.ChainIDs
		GetVrfChainList() common.ChainIDs
		GetAllChainInfos() []*common.ChainInfos
		// GetGenesisNodes() map[common.NodeID]common.NodeType
		// CreateTestAccount(chainid common.ChainID, addr common.Address, balance *big.Int, local *big.Int) error
		// ForceCommit(chainid common.ChainID) error
		// GetAccount(addr *common.Address, chainID common.ChainID) (Account, bool)
		GetChainData(chainid common.ChainID) (DataHolder, error)
		GetMainChainLong(addr common.Address, key common.Hash) []byte
		GetChainLong(chainid common.ChainID, addr common.Address, key common.Hash) []byte
		RemoveChain(chainid common.ChainID)

		SetCursorManually(to common.Height) error

		GetRewardChainID() common.ChainID
		GetCurrentEra() (common.EraNum, *common.Hash, bool)
		GetNextEra() (common.EraNum, *common.Hash, bool)
		GetCurrentRRProofs() (common.EraNum, *common.Hash, *RRProofs, bool)
		GetNextRRProofs() (common.EraNum, *common.Hash, *RRProofs, bool)
		ChangeEra(era common.EraNum, root, next *common.Hash) bool
		ChangeRRProof(era common.EraNum, isCurrent bool, root *common.Hash, proofs *RRProofs) bool
		// set flag of proof requesting
		SetRequesting(r bool) bool

		// initRREraProofs(era common.EraNum, hash *common.Hash, proof *RRProofs, nextHash *common.Hash, nextProof *RRProofs)
		ReadOnly() DataManager
		// GetStartNodes() common.NodeIDs
		AddStartNode(id common.NodeID)
		// StartNodesSize() int
		AddLastComm(lastComm *LastCommEMessage) error
		ToStartComm(chainIds common.ChainIDs) (*StartCommEMessage, error)
		// cache seed
		SetSeed(epoch common.EpochNum, newseed *common.Seed) bool
		GetSeed(header *BlockHeader) (*common.Seed, error)
		LastSeedUpdatedAt() common.EpochNum
		SaveCommitteeAt(at common.ChainID, commChain common.ChainID, epoch common.EpochNum,
			startHeight common.Height, electedHeight common.Height, comm, prev *Committee) error
		GetCommitteeAt(at common.ChainID, commChain common.ChainID, height common.Height) (*Committee, error)
		StoreWorkingChains(chains map[common.ChainID]bool) error
		LoadWorkingChains() (map[common.ChainID]bool, error)
		AllChainSynced(mainHeight common.Height) error
		GetLogs(cid common.ChainID, filter *RpcFilter) ([]*Log, error)
		SetDB(newDB db.Database)
	}

	P2PServer interface {
		// get boot chain id
		BootChain() common.ChainID
		// discovery type is sort
		DiscoverTypeIsSRT() bool
		// set chains dataNodes to discovery table tmpNodes
		SetTmpDataNodes(infos []*common.ChainInfos)
		// replace discovery dataNodes with tmpNodes
		ReplaceDataNodes()
		// abandon useless peers in ChainToPeers
		AbandonUselessPeers()
		// start server
		Start() error
		// stop server
		Stop()
		// get the local nodeId
		NodeID() *common.NodeID
		// get the server local port
		LocalPort() uint16
		// broadcast message use goroutine
		BroadcastAsync(info string, msgv interface{}, pub, sig []byte, skips ...*common.NodeID) ([]byte, []byte, error)
		// send a message to oriented nodes
		SendToNode(info string, toNodes common.NodeIDs, pb interface{}, pub, sig []byte) ([]byte, []byte, error)
		// send a message to my peer
		SendToPeer(info string, toNodes common.NodeIDs, pb interface{}, pub, sig []byte) ([]byte, []byte, error)
		// send a message to another chain
		SendToChain(info string, chainid common.ChainID, pb interface{}, pub, sig []byte) ([]byte, []byte, error)
		// randomly select size peers to send messsages
		RandBroadcast(size int, info string, msgv interface{}, pub, sig []byte,
			skips ...*common.NodeID) ([]byte, []byte, error)
		// synchronous broadcast, others not specified are sent asynchronously
		BroadcastSync(info string, msgv interface{}, pub, sig []byte, skips ...*common.NodeID) ([]byte, []byte, error)
	}

	ConnectedCallBackFunc func(id common.ChainID, netType common.NetType, server P2PServer)

	Networker interface {
		// Create start a boot node
		Create(typ common.NetType, addr net.Addr, boots map[common.NodeID]net.Addr, infos []*common.ChainInfos, callback ConnectedCallBackFunc) error
		// Connect connect to p2p network with a boot node
		Connect(typ common.NetType, bootId common.ChainID, boots map[common.NodeID]net.Addr, infos []*common.ChainInfos, permission []byte, callback ConnectedCallBackFunc) error
		// Reset reset a boot node
		Reset(typ common.NetType, addr net.Addr, callback ConnectedCallBackFunc) error
		// Exit exit from current p2p network
		Exit(typ common.NetType) (int, error)
		// Check whether a certain net type exists
		IsIn(typ common.NetType) bool
		// Get chain id that the net worker belongs to
		GetChainID() common.ChainID
		// Set data net discovery table's tmpNodes
		SetTmpDataNodes(nt common.NetType)
		// Replace discovery table's dataNodes with tmpNodes
		ReplaceDataNodes(nt common.NetType)
		// Abandon useless peers
		AbandonUselessPeers(nt common.NetType)
		// broadcast asynchronized
		Broadcast(info string, typ common.NetType, msg interface{},
			pub, sig []byte, skips ...*common.NodeID) ([]byte, []byte, error)
		// SendToNode send a message to a specific node in p2p network
		SendToNode(info string, typ common.NetType, nodeids common.NodeIDs,
			msg interface{}, pub, sig []byte) ([]byte, []byte, error)
		SendToPeer(info string, typ common.NetType, nodeids common.NodeIDs,
			msg interface{}, pub, sig []byte) ([]byte, []byte, error)
		SendToChain(info string, typ common.NetType, chainid common.ChainID,
			msg interface{}, pub, sig []byte) ([]byte, []byte, error)
		Rand(size int, info string, typ common.NetType, msg interface{}, pub, sig []byte,
			skips ...*common.NodeID) ([]byte, []byte, error)
		// broadcast synchronized
		BroadcastSync(info string, typ common.NetType, msg interface{},
			pub, sig []byte, skips ...*common.NodeID) ([]byte, []byte, error)
	}

	NetworkManager interface {
		common.Service
		InitChain(id common.ChainID) error
		GetDataServer(chainId common.ChainID) *[]common.Dataserver
		GetNetworker(id common.ChainID) Networker
		BroadcastFull(info string, skip *common.NodeID, cid common.ChainID, ntp common.NetType,
			pb interface{}, pub, sig []byte) error
		BroadcastFullSync(info string, skip *common.NodeID, cid common.ChainID, ntp common.NetType,
			pb interface{}, pub, sig []byte) error
		SendToNode(info string, ntp common.NetType, chainId common.ChainID, to common.NodeIDs,
			pb interface{}, pub, sig []byte) error
		SendToPeer(info string, ntp common.NetType, chainId common.ChainID, toNodes common.NodeIDs,
			pb interface{}, pub, sig []byte) error
		SendToChain(info string, ntp common.NetType, fromChain common.ChainID, toChain common.ChainID,
			pb interface{}, pub, sig []byte) error
		Rand(size int, info string, chainId common.ChainID, ntp common.NetType, msg interface{}, pub, sig []byte,
			skips ...*common.NodeID) error
		GetChainNet(id common.ChainID, netType common.NetType) (map[common.NodeID]net.Addr, bool)
		StartConNet(networker Networker, chainid common.ChainID, netType common.NetType) (common.NodeID, error)
		CreateOrConnectNet(ntp common.NetType, bootChainID, localChandID common.ChainID) error
		IsBootNode(id common.ChainID) bool
		ClearNetWorker(id common.ChainID)
		InitNet(chaininfo *common.ChainInfos) error
		StopOneNet(cid common.ChainID, ntp common.NetType) (int, error)
		ResetNet(chainid common.ChainID, ntp common.NetType) error
		ConnectNet(chaininfo *common.ChainInfos) error
		ReviveNet(chaininfo *common.ChainInfos, epoch common.EpochNum) error
		Status()
	}

	Noticer interface {
		common.Service
		CanPublish(block *BlockEMessage) bool
		Publish(block *BlockEMessage, receipts []*Receipt) error
	}
)

func (ss *ChainSnapshot) String() string {
	if ss == nil {
		return "Snapshop<nil>"
	}
	return fmt.Sprintf("Snapshot{Height:%s Waterlines:%s Block:{%s} CheckEpoch:%t}",
		&(ss.Height), ss.Waterlines, ss.Block.FullString(), ss.CheckEpoch)
}

func (ww *WholeWorld) String() string {
	t := func(v interface{}) string {
		val := reflect.ValueOf(v)
		if val.Kind() == reflect.Ptr {
			if val.IsNil() {
				return "<nil>"
			} else {
				return "[not nil]"
			}
		}
		return ""
	}
	return fmt.Sprintf("{State:%s Chains:%s History:%s Waterlines:%d Vcc:%s Cashed:%s RR:%s RRN:%s RRC:%s}",
		t(ww.State), t(ww.Chains), t(ww.History), len(ww.Waterlines), t(ww.Vcc),
		t(ww.Cashed), t(ww.RRCurrent), t(ww.RRNext), t(ww.RRChanging))
}

func (pr *ProposeResult) ToHash(bs []byte) *common.Hash {
	if len(bs) == 0 {
		return nil
	}
	return common.BytesToHashP(bs)
}

func (pr *ProposeResult) FromHash(h *common.Hash) []byte {
	if h == nil {
		return nil
	}
	return h.Bytes()
}

func (pr *ProposeResult) TrieRoot(root []byte) []byte {
	if trie.IsEmptyTrieRoot(root) {
		return nil
	}
	return root
}

type StateStreams struct {
	Accounts    [][]byte
	Storages    [][]byte
	Codes       [][]byte
	Longs       [][]byte
	Deltas      [][]byte
	Chains      []byte
	Confirmeds  []byte
	BridgeInfos []byte
	BridgePeers []byte
}
